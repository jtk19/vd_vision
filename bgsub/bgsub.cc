#include <stdlib.h>
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <sstream>

#include <opencv/cv.h>
#include <opencv/cxcore.h>

#include <opencv2/video.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/objdetect.hpp>
#include <opencv2/features2d.hpp>
#include <opencv2/videoio/videoio_c.h>
#include <opencv2/video/background_segm.hpp>


using namespace std;
using namespace cv;


Ptr<BackgroundSubtractorMOG2> pMOG2;
//Ptr<BackgroundSubtractorKNN> pMOG2;

void doGrabCut( Mat *pframe );

int bgsubMOG2( Mat *frame );
void alphaBlend(Mat& foreground, Mat& background, Mat& alpha, Mat& outImage);


int main( int argc, char *argv[] )
{

	namedWindow("Frame", WINDOW_NORMAL | WINDOW_KEEPRATIO );
	namedWindow("FG Mask MOG 2", WINDOW_NORMAL | WINDOW_KEEPRATIO );
	namedWindow("BG Removed", WINDOW_NORMAL | WINDOW_KEEPRATIO );
	cv::moveWindow( "Frame", 10, 640 );
	cv::moveWindow( "FG Mask MOG 2", 1260, 0);
	cv::resizeWindow( "FG Mask MOG 2", 640, 910 );
	cv::moveWindow( "BG Removed", 600, 0);
	cv::resizeWindow( "BG Removed", 640, 910 );

	pMOG2 = createBackgroundSubtractorMOG2( 500, 32, false ); //MOG2 approach
	//pMOG2 = createBackgroundSubtractorKNN( 500, 500, false );

	for ( int f = 1; f < 19; ++f )
	{
		stringstream ss, ws;

		if ( f == 6 ) continue;

		ss << "/home/data/veed/video/0/" << f << ".avi";
		ws << "/home/data/veed/write/"<< f << "_bgsub.avi";

		cv::VideoCapture cap( ss.str() );
		VideoWriter writer;
		cv::Mat m_bgr;

		for ( size_t i = 0; i < 10000; ++i )
		{
			try
			{
				if ( cap.read(m_bgr) == false )
				{
					cout<< i<< " frames"<< endl;
					break;
				}
			}
			catch (...)
			{
				cout<< i<< " frames"<< endl;
				break;
			}

			//bgsubMOG2( &m_bgr );
			doGrabCut( &m_bgr );

			if ( i == 0 )
			{
				writer.open( ws.str(), CV_FOURCC('X','2','6','4'), 25, m_bgr.size() );
			}
			writer.write( m_bgr );


		}

		writer.release();
		cap.release();
	}

	char ch;  cout<< "Enter: "<< endl; cin >> ch;

	return 0;
}



void doGrabCut( Mat *pframe )
{
	cv::Mat result; // segmentation result (4 possible values)
	cv::Mat bgModel,fgModel; // the models (internally used)
	Mat background;

	imshow("FG Mask MOG 2", *pframe );

	Mat image = (*pframe).clone();
	Mat image2 = image.clone();

	// define bounding rectangle
	cv::Rect rectangle( 40, 90, image.cols-40, image.rows-90);

	cout<< "getting grabcut...";
	// GrabCut segmentation
	cv::grabCut(image,    // input image
	            result,   // segmentation result
	            rectangle,// rectangle containing foreground
	            bgModel,fgModel, // models
	            1,        // number of iterations
	            cv::GC_INIT_WITH_RECT); // use rectangle
	cout<< "done"<< endl;

	// Get the pixels marked as likely foreground
	cv::compare(result,cv::GC_PR_FGD,result,cv::CMP_EQ);
	// Generate output image
	cv::Mat foreground(image.size(),CV_8UC3,cv::Scalar(255,255,255));
	//cv::Mat background(image.size(),CV_8UC3,cv::Scalar(255,255,255));
	image.copyTo(background,~result);// bg pixels not copied

	// draw rectangle on original image
	cv::rectangle(image, rectangle, cv::Scalar(255,255,255),1);

	imwrite("img_1.jpg",image);

	background = image2 - foreground;
	imwrite("Background.jpg",background);

	imshow( "BG Removed", foreground );
	imshow( "Frame", background );

	waitKey(0);

}

int bgsubMOG2( Mat *pframe )
{
	Mat fgMaskMOG2, bgRem( pframe->size(), CV_8UC3, Scalar( 255, 255, 255) ); //fg mask fg mask generated by MOG2 method
	Mat bg( pframe->size(), CV_8UC3, Scalar( 255, 255, 255) );
	//bgRem = *pframe;

	pMOG2->apply( *pframe, fgMaskMOG2 );

	cv::GaussianBlur( fgMaskMOG2, fgMaskMOG2, Size( 81, 81), 40, 40 );
	threshold( fgMaskMOG2, fgMaskMOG2, 2, 255, THRESH_BINARY);

	//alphaBlend( *pframe, bg, fgMaskMOG2, bgRem);
	(*pframe).copyTo( bgRem, fgMaskMOG2 );

	imshow("FG Mask MOG 2", fgMaskMOG2);
	imshow("BG Removed", bgRem );
	cv::waitKey( 1 );

	return 0;
}

void alphaBlend(Mat &foreground, Mat &background, Mat &alpha, Mat &outImage)
{
	Mat fg, bg, alf, bet;
	foreground.convertTo( fg, CV_32FC3);
	background.convertTo( bg, CV_32FC3);

	Mat in[] = { alpha, alpha, alpha };
	merge( in, 3, alf );
	alf.convertTo( alf, CV_32FC3, 1.0/255);

	multiply( fg, alf, fg);

	multiply(  bg, Scalar::all(1.0)-alf, bg);

	add( fg, bg, outImage);

}






